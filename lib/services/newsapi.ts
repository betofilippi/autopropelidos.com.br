import { NewsItem } from '@/lib/types'

interface NewsAPIArticle {
  source: {
    id: string | null
    name: string
  }
  author: string | null
  title: string
  description: string | null
  url: string
  urlToImage: string | null
  publishedAt: string
  content: string | null
}

interface NewsAPIResponse {
  status: string
  totalResults: number
  articles: NewsAPIArticle[]
}

const NEWS_API_KEY = process.env.NEWS_API_KEY
const NEWS_API_URL = 'https://newsapi.org/v2'

// Cache configuration
const CACHE_DURATION = 15 * 60 * 1000 // 15 minutes
const cache = new Map<string, { data: NewsItem[], timestamp: number }>()

// Rate limiting configuration
let lastRequestTime = 0
const MIN_REQUEST_INTERVAL = 1000 // 1 second between requests

export class NewsAPIService {
  private async makeRequest(url: string): Promise<NewsAPIResponse> {
    // Rate limiting
    const now = Date.now()
    const timeSinceLastRequest = now - lastRequestTime
    if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
      await new Promise(resolve => setTimeout(resolve, MIN_REQUEST_INTERVAL - timeSinceLastRequest))
    }
    lastRequestTime = Date.now()

    const response = await fetch(url, {
      headers: {
        'X-Api-Key': NEWS_API_KEY || '',
      },
    })

    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.')
      }
      throw new Error(`NewsAPI request failed: ${response.statusText}`)
    }

    return response.json()
  }

  private mapArticleToNewsItem(article: NewsAPIArticle): NewsItem {
    return {
      id: '', // Will be generated by Supabase
      title: article.title,
      excerpt: article.description || article.content?.substring(0, 200) || '',
      content: article.content || article.description || '',
      image_url: article.urlToImage,
      source: article.source.name,
      source_url: article.url, // This will be mapped to 'url' column in sync service
      published_at: article.publishedAt,
      category: this.categorizeArticle(article),
      created_at: new Date().toISOString(),
    }
  }

  private categorizeArticle(article: NewsAPIArticle): string {
    const title = article.title ? article.title.toLowerCase() : ''
    const description = article.description ? article.description.toLowerCase() : ''
    const content = article.content ? article.content.toLowerCase() : ''
    const text = `${title} ${description} ${content}`

    if (text.includes('lei') || text.includes('regulamenta') || text.includes('norma') || text.includes('decreto')) {
      return 'legislacao'
    }
    if (text.includes('segur') || text.includes('acidente') || text.includes('capacete') || text.includes('proteção')) {
      return 'seguranca'
    }
    if (text.includes('manuten') || text.includes('bateria') || text.includes('motor') || text.includes('reparo')) {
      return 'manutencao'
    }
    if (text.includes('sustentável') || text.includes('ecológic') || text.includes('verde') || text.includes('carbono')) {
      return 'sustentabilidade'
    }
    return 'noticias'
  }

  async searchNews(query: string, language: string = 'pt'): Promise<NewsItem[]> {
    // Check cache first
    const cacheKey = `${query}-${language}`
    const cached = cache.get(cacheKey)
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      return cached.data
    }

    try {
      const encodedQuery = encodeURIComponent(query)
      const url = `${NEWS_API_URL}/everything?q=${encodedQuery}&language=${language}&sortBy=publishedAt&pageSize=50`
      
      const data = await this.makeRequest(url)
      const newsItems = data.articles.map(article => this.mapArticleToNewsItem(article))
      
      // Update cache
      cache.set(cacheKey, {
        data: newsItems,
        timestamp: Date.now(),
      })

      return newsItems
    } catch (error) {
      console.error('Error fetching news from NewsAPI:', error)
      throw error
    }
  }

  async searchMultipleQueries(queries: string[], language: string = 'pt'): Promise<NewsItem[]> {
    const allNews: NewsItem[] = []
    const seenUrls = new Set<string>()

    for (const query of queries) {
      try {
        const news = await this.searchNews(query, language)
        
        // Filter out duplicates
        for (const item of news) {
          if (!seenUrls.has(item.source_url)) {
            seenUrls.add(item.source_url)
            allNews.push(item)
          }
        }
      } catch (error) {
        console.error(`Error fetching news for query "${query}":`, error)
        // Continue with other queries even if one fails
      }
    }

    // Sort by published date (newest first)
    return allNews.sort((a, b) => 
      new Date(b.published_at).getTime() - new Date(a.published_at).getTime()
    )
  }

  async getLatestNews(): Promise<NewsItem[]> {
    const queries = [
      'autopropelidos',
      'mobilidade urbana patinete',
      'patinete elétrico brasil',
      'micromobilidade',
      'veículo elétrico individual',
    ]

    return this.searchMultipleQueries(queries)
  }

  // Get news from Portuguese-language sources
  async getPortugueseNews(): Promise<NewsItem[]> {
    const queries = [
      'autopropelidos brasil',
      'patinete eletrico',
      'mobilidade urbana',
      'micromobilidade',
    ]

    try {
      // Also try to get news from Brazilian domains
      const domainQuery = 'site:globo.com OR site:uol.com.br OR site:estadao.com.br OR site:folha.com.br patinete elétrico'
      const domainNews = await this.searchNews(domainQuery, 'pt')
      const regularNews = await this.searchMultipleQueries(queries, 'pt')
      
      // Combine and deduplicate
      const allNews = [...domainNews, ...regularNews]
      const uniqueNews = Array.from(
        new Map(allNews.map(item => [item.source_url, item])).values()
      )

      return uniqueNews.sort((a, b) => 
        new Date(b.published_at).getTime() - new Date(a.published_at).getTime()
      )
    } catch (error) {
      console.error('Error fetching Portuguese news:', error)
      return this.searchMultipleQueries(queries, 'pt')
    }
  }
}

export const newsAPIService = new NewsAPIService()